#include <xc.h>

// ??????? Configuration Bits
// CONFIG
#pragma config FOSC = INTOSCIO        // Oscillator Selection bits (HS oscillator: High-speed crystal/resonator on RA6/OSC2/CLKOUT and RA7/OSC1/CLKIN)
#pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled)
#pragma config PWRTE = ON       // Power-up Timer Enable bit (PWRT enabled)
#pragma config MCLRE = OFF      // RA5/MCLR pin function select (RA5/MCLR pin function is digital input, MCLR internally tied to VDD)
#pragma config BOREN = OFF      // Brown-out Reset Enable bit (BOD Reset disabled)
#pragma config LVP = OFF        // Low-Voltage Programming Enable bit (RB4/PGM pin has digital I/O function, HV on MCLR must be used for programming)
#pragma config CPD = OFF        // Data Code Protection bit (Data memory code protection off)
#pragma config CP = OFF         // Code Protection bits (Program memory code protection off)

#define _XTAL_FREQ 4000000 // ?????? ??????? 8 ???????

unsigned int pwm_value =50; // ????? ????? PWM (50% Duty Cycle)
unsigned int display_index = 0;


unsigned int button_delay = 0; 

void setupPWM(void) {
    // ??????? ???????
    TRISBbits.TRISB3 = 0; // ????? ??? RB3 ?? ????? ????? (??? PWM)
    
//    // ??????? ?????1
//    T1CON = 0b00110001; // ?????1 ???? ?? prescaler 1:8
//    TMR1 = 0;
//    TMR1IE = 1; // ???? ???? ???? ?????1
    
   // ??????? ?????2
    T2CON = 0b00000110;  // ?????2 ???? ?? prescaler 1:4
    PR2 = 210;  // ????? ???? PWM ???? ?????? 208 ????
    
    // ??????? CCP1 ???? ?? PWM
    CCP1CON = 0b00001100;  // ?? PWM ????
    
    // ????? Duty Cycle
    CCPR1L = (pwm_value * 10 ) >> 2;
    //CCP1CONbits.DC1B = pwm_value & 0x03;
    
    // ???? ???? ?????2
    TMR2ON = 1;
    
    // ???? ???? ???????? ?????2
    TMR2IE = 1; // ???? ???? ???? ?????2 
    
    
////    // ??????? CCP1 ???? ?? PWM
//    CCP1CON = 0b00001100; // ?? PWM ????
//    CCPR1L = pwm_value >> 2; // ????? Duty Cycle
////    CCP1CONbits.DC1B = pwm_value & 0x03; // ??????? ???????? Duty Cycle
////    
//    

    // ??????? ?????0
    OPTION_REG = 0b00000100; // ?????0 ???? ?? prescaler 1:32
    TMR0 = 0;
    TMR0IE = 1;
            
            
    PEIE = 1;
    GIE = 1;
}
void updatePWM(void) {
   // ??????????? PWM ?? ??????? ?? ?????1
   // TMR1 = 65536 - ((_XTAL_FREQ / 8) / 208); // ????? ???? ?????? 208 ????
    CCPR1L = (pwm_value * 10 ) >> 2;

}
void display7Segment(unsigned int value, unsigned int digit) {
    switch(value) {
        case 0: 
        {
            PORTA = 0b11000000 ;
            PORTBbits.RB5 = 0 ; 
        }
         break; // ????? 0
        case 1: {PORTA = 0b01111001;
        PORTBbits.RB5 = 1 ; 
        
        } break; // ????? 1
        case 2: {PORTA = 0b00100100; 
        PORTBbits.RB5 = 1 ; 
        
        }break; // ????? 2 
        case 3: {PORTA = 0b00110000;
        PORTBbits.RB5 = 1 ; 
        
        } break; // ????? 3 
        case 4: {PORTA = 0b00011001; 
        PORTBbits.RB5 = 0 ; 
        
        
        }break; // ????? 4 
        case 5: {PORTA = 0b00010010;
        PORTBbits.RB5 = 0 ; 
        
        } break; // ????? 5 
        case 6:{ PORTA = 0b00000010;
        PORTBbits.RB5 = 0 ; 
        
        } break; // ????? 6  
        case 7: {PORTA = 0b01111000;
        PORTBbits.RB5 = 1 ; 
        
        }break; // ????? 7
        case 8: {PORTA = 0b00000000; 
        PORTBbits.RB5 = 0 ; 
        
        }break; // ????? 8
        case 9: {PORTA = 0b00010000;
        PORTBbits.RB5 = 0 ; 
        
        } break; // ????? 9 
        default: {PORTA =0b01111111;
        PORTBbits.RB5 = 1 ; 
        
        } break; // ?????
    }
    if (digit)
    {
       PORTBbits.RB6 = 0 ;
       PORTBbits.RB7 = 1 ;  
    }else
    {
      PORTBbits.RB6 = 1 ; 
      PORTBbits.RB7 = 0 ;  
    }
}

void __interrupt() ISR(void) {
    if (TMR2IF) {
        TMR2IF = 0;
      
       //RB3 = !RB3; // ????? ????? ??? PWM
        
//            if (TMR1 >= pwm_value) {
//            RB3 = 0; // ????? ?????
//        } else {
//            RB3 = 1; // ????? ????
//        }
//        TMR1 = 65536 - ((_XTAL_FREQ / 8) / 208); // ????? ?????1 ???? ?????? 208 ????

         updatePWM();
         //RB3 = (pwm_value > (TMR1 >> 8)) ? 1 : 0; // ????? ????? ??? PWM ?? ???? ????? ?????
    }

    if (TMR0IF) {
        TMR0IF = 0;
        TMR0 = 255 - (_XTAL_FREQ / (32 * 1000)); // ???? ?????????? ?? ?????? 1 ????????
        


        // ?????????? ???? ?????????
        unsigned int tens = pwm_value / 10;
        unsigned int ones = pwm_value % 10;
        if (display_index == 0) {
            display7Segment(tens, 0); // ????? ?????
            display_index = 1;
        } else {
            display7Segment(ones, 1); // ????? ????
            display_index = 0;
        }
               // ?????? ????? ???????
        if (button_delay > 0) {
            button_delay--;
        }
    }

 

    // ????? ????? ??????? ?? ???? ?????1
    if (!RB1 && button_delay == 0 ) {
       // pwm_value++;
        
        pwm_value = (pwm_value < 70) ? pwm_value + 1 : 70;
         button_delay = 100; // ????? ????? ?? ????? (?? ??? ???? ?????0 ?? 1 ??????????)
    } else if (!RB2 && button_delay == 0 ) {
       // pwm_value--;
          pwm_value = (pwm_value > 0) ? pwm_value - 1 : 0;
         button_delay = 100; // ????? ????? ?? ????? (?? ??? ???? ?????0 ?? 1 ??????????)
    }
      //  display7Segment(pwm_value / 10); // ????? ????? ??? 7?????
        INTF = 0; // ??? ???? ??? ????
   // }
}

void main(void) {
    setupPWM();
     TRISBbits.TRISB1 = 1;
      TRISBbits.TRISB2 = 1 ; 
      OPTION_REGbits.nRBPU = 0; // ???? ???? ?????? ?????? ????? ???? ???? B

    
      TRISBbits.TRISB5 = 0;
      TRISBbits.TRISB6 = 0 ;  
      TRISBbits.TRISB7 = 0 ;  
    TRISBbits.TRISB0 = 1; // ????? ??? RB0 ?? ????? ????? (???? 1)
    TRISBbits.TRISB1 = 1; // ????? ??? RB1 ?? ????? ????? (???? 2)
   // TRISAbits.TRISA = 0b00000000; // ????? ??????? PORTA ?? ????? ????? (7?????)
    TRISA = 0b00000000 ; 
    
    INTE = 1; // ???? ???? ???? ?????
    GIE = 1; // ???? ???? ???????

   
    while(1) {
// //***********************************************       
//             if (!RB1) {
//            pwm_value++;
//        } else if (!RB2) {
//            pwm_value--;
//        }
//             
//              unsigned int tens = pwm_value / 10;
//        unsigned int ones = pwm_value % 10;
//        if (display_index == 0) {
//            display7Segment(tens, 0); // ????? ?????
//            display_index = 1;
//        } else {
//            display7Segment(ones, 1); // ????? ????
//            display_index = 0;
//        }
//        
//        
//  //*****************************************      
        
   
             
//        for (int i =0 ; i < 10 ; i ++)
//        {
//            display7Segment(i);
//         __delay_ms(100);
//        }
//        
//        // ??? ????????
    }
}
